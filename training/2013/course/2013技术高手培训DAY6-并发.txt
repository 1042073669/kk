技术高手培训DAY6

课程主题：JAVA并发

主讲：秦金卫(kimmking)

本次整理：陈星晓（小猫）

时间：2013-11-20 

一、问题的提出：
	小猫在学习JAVA并发的时候打算写一个模拟抢票的例子（见附件），并从网上寻找几种解决多线程并发的方案。
	在测试过程中，有一种方法是将synchronized关键字加在Interger的变量上，导致测试结果并非预期那样达到线程安全。
	小猫对此是百思不得其解……

关键代码如下：
/**
 * ?????锁住tickets对象但是不能实现线程安全????，万分不理解啊
	顾客1 准备抢票...
	顾客7 准备抢票...
	顾客4 准备抢票...
	顾客5 准备抢票...
	顾客9 准备抢票...
	顾客0 准备抢票...
	顾客2 准备抢票...
	顾客6 准备抢票...
	顾客8 准备抢票...
	顾客3 准备抢票...
	*********顾客1***********抢到票啦，当前剩余车票数量[2]
	*********顾客7***********抢到票啦，当前剩余车票数量[1]
	*********顾客5***********抢到票啦，当前剩余车票数量[0]
	*********顾客3***********抢到票啦，当前剩余车票数量[2]
	>>>>>>>>>>>>>>>>>顾客9来得太晚，车票被抢光啦。。。[-1]
	>>>>>>>>>>>>>>>>>顾客0来得太晚，车票被抢光啦。。。[-2]
	*********顾客4***********抢到票啦，当前剩余车票数量[2]
	>>>>>>>>>>>>>>>>>顾客2来得太晚，车票被抢光啦。。。[-3]
	>>>>>>>>>>>>>>>>>顾客6来得太晚，车票被抢光啦。。。[-4]
	>>>>>>>>>>>>>>>>>顾客8来得太晚，车票被抢光啦。。。[-5]
 */
public class TicketBroker {
	private Integer tickets = 5;
	public void sellTicket(String name) {
		synchronized (tickets) {//锁住tickets对象，但是木有用????
			tickets--;
			if (tickets >= 0) {
				System.out.println("*********" + name + "***********抢到票啦，当前剩余车票数量[" + tickets + "]");
			} else {
				System.out.println(">>>>>>>>>>>>>>>>>" + name + "来得太晚，车票被抢光啦。。。[" + tickets + "]");
			}
	}
	
}



二、问题分析
          上面的程序问题出在tickets--;这句代码上。
	tickets--这个操作，使得tickets 指向的对象变了。
	tickets开始是Integer(5)
    tickets-- 相当于   int t = 拆箱，出来5
    t = t -- = 4
    tickets = new Integer(4) 这个时候 tickets 被重新赋值成一个新对象了。
          当第二个线程再次调用到sellTicket(String name)这个方法，进来一看tickets这个对象上没有锁，就直接走下去了，这就导致了结果是线程不安全的。
          
          
三、JAVA的锁机制
        简单的说，JAVA的锁就是一个标识，比如一个对象 在java里的内存表示是：0100000000.......
        那么，一般指定前面的某个二进制位为锁标识位。比如第二位，如果是1，表示这个对象上锁了。
         如果是0，表示这个对象没锁。一个线程操作一个对象的时候，先检查这个位，看自己能不能拿到锁，拿到锁，就设置1，自己继续操作。
         发现已经有锁了，就自己干等着，一直到用着锁的线程，释放这个锁，这就是锁的本质。
         
         锁，可以锁加到一个变量对象上，可以加到一段代码上，可以加到一个方法上，也可以锁this，锁一个class，其实都是加到某个对象上。
         方法上的锁，也是加在this上，前提是只有进入这个方法的时候，才加到this上。
         静态方法，同理的加到Klass上。
         
         
四、再次谈锁
	对于如下代码，同样存在着线程不安全的问题，因为lock对象的指针在同步块代码中被指向到了新的对象指针上，而新的对象上是没有锁的，这就导致了锁失效。
	Object lock = new Object();
	public void method1(){
	    synchronized(lock){   
	    	lock = new Object();
	    	//do something...
	    }
	}
	现在大家可以明白为什么多线程代码，从外面引入的变量，必须是final的吧，显示要求传递到多线程内的变量都是不可变的。


五、关于可变类型(mutable)和不可变类型(immutable)
	像scala 之类的语言，会显示的区分可变类型和不可变类型，而JAVA语言没有这个区别。
	
	举个例子：
	List  sort(List list) { ... }这个在java里，其实是有歧义的。
	因为你搞不清楚，sort之后返回的List对象，是不是原先的那个：有可能是原来的对象（只是里面的item位置变了），有可能被指向了重新new的一个List实例。
	这个在多线程的时候，非常重要。

	
六、其他
本次还讨论了如何将Webservice调用将无状态改为有状态的问题。
因为的该部分内容与JAVA并非关系不大，我也还没完全理解，等下次我写出例子并整理后再给大家发。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	