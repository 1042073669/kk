技术高手培训DAY4

课程主题：IO(文件io和网络io)

主讲：秦金卫(kimmking)

本次整理：董碧莹（快乐）

时间：2013-11-14 16:27:35 - 2013-11-09 17:46:07 

一、IO概念：
	1、IO:顾名思义就是输入输出 Input Output。这是计算机程序最基础的一个概念。
所有程序从执行层面来看，不管是整体，还是任意的一个局部，都是输入+处理+输出。
	例如：
		  public class Hello {   
			  public static void main(String[] args){ 
			  System.out.print("hello");
			  }
		  }
	这个程序，输入是args,输出是在屏幕上打印一个hello。输入输出是最基本的概念之一。
	2、常用的io:
		文件IO和网络IO
		1)文件IO:就是从磁盘存储里输入数据到内存;内存，输出数据到磁盘存储。
			简单的说，就是写和读。
		2)网络io：就是把远程发过来的数据，接收到内存;把内存中的数据输出到远程。
			就是发送和接收。
	这两个过程，抽象出来，基本结构是相同的。
	
二、文件IO
	1、底层的两个概念：文件句柄、存储空间。
		文件句柄：相当于文件标识符（比如文件全路径），通过这个标识，操作系统可以
			去存储磁盘上去找相应的数据。而我们通过操作系统和jdk提供的工具方法，
			只需要通过io直接处理文件即可。内部细节，全都不需要我们知道了。
			这就是io抽象出来的好处。
	2、最普通的文件处理方式：	
		1)通过 file的路径，打开一个 InputStream，
		2)创建一个大的 byte[]	
		3)一直用InputStream read,读到数组里来,读完，关闭掉 stream。
	　*这里面的几个问题：
		1)如果文件很大，这么搞的话，需要非常大的内存。
		　而平时我们从文件里读出来数据，一般不需要一次性的全部处理。
		　比如，我们或者可以按行处理，这样，其实每次内存里有一行数据就够了，
		　把整个文件处理完，也几乎不怎么需要内存。（xml文件处理的SAX方式）。
		　*改进：
			对于二进制文件数据的处理，就是，读取的时候，new一个固定大小的byte[]，
			比如8K，然后，每次读8K数据，处理完，再读8K，依次类推。	
			额外需要注意的是最后一次读取的数据，可能不慢8K，需要记录实际数据量。	
			这样，就相当于用8K数组，自己做了一个buffer，把这些对缓存byte数组的操作，封装起来，	
			就是屁冬讲的 NIO里的Buffer的由来了。	
		2)大部分情况下，我们接触到的文件，都是有自己的文件格式的，
		  比如 最最常见的就是文本文件，log日志啊，CSV啊，等等。
		  用 InputStream读出来的都是 byte，所以，需要处理的另一个问题就是编码转换,
		  文件都是 byte,把String往文件里写，得先转成byte[],从文件里直接读出来的，也是byte[]
		  也需要转成 String，或其他的数据结构。
		 *怎么办呢？
		  这就抽象出来了另外一个东西 Writer和Reader，他们的抽象程度比 InputStream和OutputStream更高，
		  关注于处理特定的数据了，而不是简单的处理原始的byte[]类型数据,比如针对文本数据，
		  设定好编码格式，就可以直接用 Writer.write( String )。
		  Read的时候可以直接 String line = reader.readLine()，而不考虑编码问题了
		  
	3、补充：
		既然每次读取的数据越少，整个处理过程消费的内存就越少，为什么不每次读1byte？
		1)因为处理的次数会变多,
		2)更主要的原因还是因为，磁盘的文件数据存储是按“ 块 " 来分配空间的。 
		  每次文件io的实际操作，都是一大块数据，而不是一个byte，
		  所以，每次尽量让io读写一个block，更合算。
		  例如：新建一个文件3字节，占用4KB。
			说明一个最小的块，就是4K。所以每次读取4K 是比较合算的。
			
		说明：文件系统就是一个大的注册表，里面说明了有多少文件，文件间的关系怎么样，
		　每个实际文件的物理存储是如何分配的。特别对linux来说，所有的东西，都是文件句柄。
	
	4、总结
		io是程序的基本概念之一。程序运行时的任意个片段都可以看做是输入+处理+输出。（这也是EIP或ESB的一些出发点）
		文件IO，就是文件处理的一些通用操作和具体应用场景功能特点的一些抽象。

三、网络io
	网络io是访问网络资源时的基础工具。
	1、一般怎么访问网络资源呢？
	　先打开一个 socket （远程主机ip，远程主机的端口），我们看到网络io，一般是跟 ip+port 有直接关系的。
	　ip我们都知道相当于 计算机的地址，计算机相当于一个房子的地址，所有程序都是一个个的人，端口相当于
	　每个人住的房间号。就整个混乱了。端口就是个标识，标识访问网络资源的程序的身份。
	2、传统的网络socket io跟文件io一样 ：
	  1)建立socket io连接
	  2)然后write可以写 byte，read可以读 byte，
		*有什么问题呢？ 
		  看一个简单的 read实现：
		  while( 有数据来了 ){  read到 byte[]； sleep(一段时间) }
		  简单的网络io，双方是相互发送数据的，中间有不确定的时间间隔。
	3、跟文件io不一样，文件在你读的时候一般都是确定的。  
	　所以，读取的线程，要一直睡觉，醒来检查，睡觉，检查。。。
	　这种一直操作的循环，把所在的线程都堵死了。这就叫 同步IO，直接消耗掉一个线程。
　　　不能放主线程，不然程序直接假死。如果每一个接入的请求，都是这么搞，很快线程
	　就会大量增加。线程间的上下文切换消费很大，性能急速下降。
  　4、跟简单文件io还有一个同样的问题就是，数据大小+缓冲的问题。
	　在网络上传输的数据包，都是固定大小的。
  　　一次 write出去一个比较大的byte[]，socket底层会自动拆成很多个小的包，　
	　然后接收方再根据包的顺序的数据，组装成原来的数据。
　　　write一个字节的数据出去，也需要消耗一个包。	
	　TCP，建立一次连接需要4次握手，断开需要3次挥手。 
	　频繁的短连接传输很小很小的数据，对性能的影响非常大。
	　io这块的抽象处理，都需要注意这些问题		
	5、缓存问题:一般在协议层和应用层，  
	  都会考虑，一定时间内缓存到足够的数据，才真正发出去，这样可以平衡实时性和性能损耗。
	  如果可能，尽量使用长连接来处理，降低无所谓的交互次数。
	  （想jdbc的创建连接需要用连接池，复用连接而不是创建新的连接，也是这个问题，代价很大）
	6、高并发下，简单的网络io处理最大的问题还是第一点，线程的损耗太大。	  
	　NIO解决这个问题的办法就是 复用线程，使得应用程序没有不必要的等待线程。  
	7、Reactor模式还是同步IO。
　　　但是直接不需要程序自己去sleep检查有没有数据到来，而是系统帮你完成这个工作，有数据来的时候，
	　让你自己的逻辑去读数据。因为读数据这个处理，还是同步的，程序自己读的，所以是同步IO
	　系统自己只需要少数的一组线程，就可以完成大量的这种等待通知工作，
	　所以，整体来看，io效率大大的提高了。
　　8、Proactor，则是更近一步，	
	　直接帮你把数据读出来，放到你指定的位置。也就是说，你自己拿到的是数据，而不是io处理事件。
	　这个才是最高级的处理方式。数据都是操作系统读完，然后告诉你的。所以，对程序来说，
	　IO操作是异步的。
　　9、Reactor、roactor这两种模式，以及高性能的server端处理模型，
　　　也就是SEDA，我们以后有机会再讲细节。
　　10、总结：
	　文件是有锁的。同一个文件，同一个时间点，只能一个程序去写。
　　　同一个文件，同一个时间点，只能一个程序去写。
	　有时候可以用来做很多好玩的事情。
	　*比如 ：一个程序怎么样禁止被用户启动两个实例？
		简单常见办法有两个
		1)在本地以写文件的方式，打开一个文件。即，持有了这样一个锁。
		 另一个实例想启动的时候，也想来拿这个锁，直接会报错。这样，就启动不了。
		2)在本地某个端口，打开一个socket,第二个实例也用这个端口来打开socket，会出错。
	  *FTP 协议:是用来传输文件的。一共就20来个命令。
		两个传输模式:主动和被动。
		传输文件的时候，单独打开一个socket连接到双方来传输数据。
	　　而本来的这个主socket连接，只传递双方的命令。
	　　这样避免干扰、命令socket和线程不会因为传输数据而被阻塞，可以随时发送命令。
	　　因为传输数据需要额外的端口和连接，跟http只有一个端口不一样，
		有时候，两端的机器在防火墙下，没法打开或是连接任意的端口。
	　　所以，主被动模式被用来设置客户端和服务器两者，传输数据的时候，谁打开端口，谁去主动连接。

四、注意
	我们的进度太慢了，本课讲完，java基础里还有好几大部分，
	所以，并发有点深，不讲了。

五、作业
	并发的基础知识

六、下期预告
	一个应用技术环节：XML
	
七、提示：
	大概还有4节课:
	一个应用技术环节：XML后，
	然后讲一节课的数据库基础
	下一节课的工具基础，
	再讲一个综合性的技术，RPC ，
	java基础就结束掉。。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	