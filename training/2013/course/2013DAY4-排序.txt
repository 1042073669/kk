技术高手培训DAY4

课程主题：几种常见的算法-冒泡排序、快速排序、基数排序、归并排序 + 编码

主讲：秦金卫(kimmking)

本次整理：钱晓峰（晓峰）

时间：2013-11-09 21:15:43 - 2013-11-09 22:27:02

一、冒泡排序

	1、算法描述：

	   答：通过两层循环，从最大或者最小，将样本中的最值一个一个冒出去。

	2、时间复杂度：

	   答：n*(n-1)/2 次，时间复杂度位O（N^2）。

	3、tips:邮件的附件里，附带了具体的实现Demo。

二、快速排序

        1、算法描述：

	   答：快排是随便找一个数，把所有比它小的放到一边，比他大的放到另一半，
	       然后再对两边进行同样操作，一直递归到所有区间都只有1个数，整个就是排序好了的。

        2、时间复杂度：

	   答：快排能做到 N*logN的复杂度。

	3、tips:邮件的附件里，附带了具体的实现Demo。

三、思考为什么快速排序比冒泡排序速度快

	1、冒泡排序：每一论循环，都是从0开始。除了冒泡出来的那个位置不用管了，
                     前面的操作步骤中包含的其他信息，都没重复利用之间的排序结果。

        2、快速排序：而快排不一样，比如第一次拿到一个数是中间位置的数，那么第一次把它放到正确的位置以后，
                     为下一步的工作，节省了大量的比较。就是：左边的数据，不需要跟右边的数据，再比较了！！！
                     这个就是核心关键。

        3、举例子说明：[3,5,2,1,4] 排序的话，快排(选择3做基准)，第一次循环后，变成[2,1,3,5,4]，那么，[2,1] 和 [5,4] 不用比较了。
		       如果用冒泡，第一搞定了5，后面4个数，还得全部都互相比较。就是这个细节，导致了平均效率的差距很大。
                       当然，从上面也可以看到，最坏的情况下，每次取的数，都是最大的，那么跟冒泡的效率是一致的。
                       快排，只是平均效率，是N*logN。


四、基数排序
	
	1、算法描述：

           答：让值和位置挂钩了，利用了数组的位置与数据的直接关系。

	2、时间复杂度：O(N)。

	3、列子说明：

	   有90个数，范围从1 - 99，互不重复，对他们进行排序new byte[100]，从给定的数组循环一遍，
           如果拿到一个数k，就 byte[k]=1，循环了一遍以后，byte里就有90个1，循环一遍byte，如果值为1，就输出下标 i，整个输出就是排序后的结果。
           神奇吧，一个比较都没用。

	4、代码Demo:
	   已知样本的范围是0~9，数组[3,5,1,7,8,2,3,6]，利用基数排序byte [] array = new byte[9](这里根据样本的范围来确定数组的大小)，第一次循环之后array=[0,1,1,2,0,1,1,1,1,0]，
	   for(int i=0;i<array.length;i++){
		byte v = array[i];
 		while(v>0){
		system.out.print(i+",");
		}
	   }
	   输出结果：1,2,3,3,5,6,7,8,

        5、tips:

	   1)使用基数排序的前提是，知道样本的取值范围，不知道范围就没法用这个办法。

	   2)空间换时间。
		
	   3）需要注意的一点是，可以证明基于比较的排序，最好的结构就是N*logN，but某些场合下，不是基于“比较”的排序，可以做到 o(N)的复杂度。

五、分治法
	
	1、设计思想：

		将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

	2、策略：

		对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，
	   这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

	3、、举例子：（取N个数中，最大（最小）的前M个值）
	   
	   10个数，找出第一和第二大的，需要比较多少次。按冒泡，第一遍，比较9次，可以拿到最大，比较8个可以拿到第二大，17次。
	   把10个数，分两半，取出每5个数中最大的那个，需要4+4=8次，比较2组取出的最大数大小1次，再取出2组最大数中最大的那个数所在数里第二大的那个，
           3次，这个数跟另一批里最大的那个比较1次。应该是13次，整体比17次，少了4次。

	4、tips：快速排序、归并排序都使用了分治思想；

六、归并排序
	
	1、算法描述：

	   答：即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。

	2、特点、特性：

	   答:归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。值得注意的是归并排序是一种稳定的排序方法。
	   将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

	3、思考：一大批数，有2亿个，内存只够放1亿个，怎么排序？

           答：分成2组，分别排序，排好以后，合并两组有序数据。两组有序数据，比如都是从小到大。那么，他们中最小的数据，肯定是两个数组最前面的这两个数据之一，
	   例如：a1 a2 a3 a4 a5 ...b1 b2 b3 b4 b5 ...，那么最小的数，肯定是a1和b1中的一个。假如是a1，那么剩下的数据就是a2 a3 a4 a5 ...b1 b2 b3 b4 b5 ...依次类推，就可以合并掉所有的数据。

	4、tips：通过大数据拆分成小数据的方式，可以分布式，并发的去排序不同的小数据，从而可以更快的处理海量数据。这是hadoop的核心思想。

七、编码

	1、什么是编码：

	   答：编码就是一种形式转换。这种转换一般是可逆的，A 编码 成 B，然后B可以再解码回来。

	2、字符集编码：
	
	   1）常用的字符集是 Unicode字符集，就是一个大字典。里面一页一页的，满满都是字符。java里，char string在内存的表示时，都是Unicode内码，什么意思呢？

	   就是 char a = 'a' 然后int aa = a；aa 就是字符 'a'的 Unicode内码。一个int值，相当于字符在Unicode字符的位置。

	   2）那什么是编码方式呢？
	
	   比如 ISO8859-1 UTF-8 GB2312  GBK GB18030 CJK，编码方式可以看做是不同方言，或者是不同的字典索引，一种映射方式。1 普通话读yi，粤语读ya都是都是1，
	   1可以看到unicode内码或字符，yi可以看做gbk编码，ya可以看做utf-8

	   3）为什么要编码？

	   因为计算机网络传输，磁盘存储，都只能存二进制！！！char string不是二进制。必须表示成byte成为二进制，才能存文件或socket传输出去。
	   所以，跟io network相关的操作才有编码如果我们都只在内存操作，不输出，就不存在编码问题。如果想让别人知道，这个byte怎么变成字符，
 	   要么你们先约定好用的是什么编码，要么你在传输的时候，设计一个报文，里面说明自己的编码HTTP头，html，jsp里的charset，encoding指令，都是这样的。

	   4）还需要特殊说明的是 ASCII 字符：

	   就是字典里，前256 个，跟编码方式一般无关，大家约定好了，这些位置都是不动的。一般我们只用英文+数字+半角标点，就没有乱码问题。
	   因为都在这些里面。还加上一些不可见的控制字符，比如 tab  回车 换行 等。


	   5）UTF-8是变长的：
	   一个char，在UTF-8编码下，byte的长度不是固定的。而且还存在一种带BOM头的UTF-8，就是跟java class一样，在前面加几个特殊byte，表示这个文件内容是 LE或BE的UTF-8，比如 'A'  用UTF-8表示可能是 一个字节，，'啦' 可能是 3个字节。
	   GB2312 只包括一些重用的汉字，GBK的范围要大一点，GBK18030包括的汉字最多。CJK包括汉字+日语+韩文 这些东亚字符编码。

八、本期作业
     秦金卫：作业我想想，明天告诉你们



九、下期预告
     
